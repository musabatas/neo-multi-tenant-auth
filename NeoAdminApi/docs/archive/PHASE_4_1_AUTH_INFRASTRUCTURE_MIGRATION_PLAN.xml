<?xml version="1.0" encoding="UTF-8"?>
<neo_commons_phase_4_1_migration_plan>
    <metadata>
        <version>1.0</version>
        <created_date>2025-08-15</created_date>
        <phase>4.1</phase>
        <phase_name>Auth Infrastructure Migration</phase_name>
        <project>NeoMultiTenant</project>
        <target_service>NeoAdminApi</target_service>
        <migration_type>auth_infrastructure_extraction</migration_type>
        <complexity_level>HIGH</complexity_level>
        <risk_level>HIGH</risk_level>
        <estimated_duration>2-3_days</estimated_duration>
        <migration_status>PLANNED</migration_status>
    </metadata>
    
    <!-- MIGRATION OBJECTIVES -->
    <objectives>
        <primary>Extract Keycloak integration infrastructure to neo-commons for multi-service reuse</primary>
        <secondary>Create protocol-based auth interfaces for maximum flexibility</secondary>
        <secondary>Implement parameterized realm/schema support for multi-tenancy</secondary>
        <secondary>Maintain backward compatibility with existing NeoAdminApi auth flows</secondary>
        <secondary>Enable future integration with NeoTenantApi and other services</secondary>
    </objectives>
    
    <!-- MIGRATION STRATEGY -->
    <strategy>
        <principle>Protocol-first with service wrappers for backward compatibility</principle>
        <approach>Extract complete auth infrastructure while maintaining existing API surface</approach>
        <validation>Comprehensive testing with existing auth flows and multi-tenant scenarios</validation>
        <rollback>Service wrapper pattern allows immediate rollback to original implementations</rollback>
    </strategy>
    
    <!-- FILES TO MIGRATE -->
    <files_to_migrate>
        <!-- Keycloak Integration Core -->
        <file_group name="keycloak_core" priority="CRITICAL" dependencies="0">
            <file path="src/integrations/keycloak/async_client.py" size="610_lines" complexity="HIGH">
                <description>Async Keycloak client with python-keycloak integration</description>
                <migration_notes>
                    <note priority="HIGH">Remove hardcoded realm references - make fully parameterized</note>
                    <note priority="HIGH">Extract connection management and client pooling</note>
                    <note priority="MEDIUM">Create protocol interfaces for client operations</note>
                </migration_notes>
                <current_issues>
                    <issue>Hardcoded admin realm in multiple methods</issue>
                    <issue>Direct settings dependency - needs injection</issue>
                    <issue>Client instance management could be shared</issue>
                </current_issues>
            </file>
            <file path="src/integrations/keycloak/token_manager.py" size="460_lines" complexity="HIGH">
                <description>Dual-validation token management with caching</description>
                <migration_notes>
                    <note priority="CRITICAL">Remove hardcoded realm defaults - inject realm provider</note>
                    <note priority="HIGH">Create token validation protocol interfaces</note>
                    <note priority="MEDIUM">Parameterize cache key patterns for multi-service use</note>
                </migration_notes>
                <current_issues>
                    <issue>settings.keycloak_admin_realm hardcoded in validation</issue>
                    <issue>Cache key patterns specific to current service</issue>
                    <issue>No realm resolution strategy - needs protocol</issue>
                </current_issues>
            </file>
            <file path="src/integrations/keycloak/realm_manager.py" size="unknown" complexity="HIGH">
                <description>Multi-tenant realm management</description>
                <migration_notes>
                    <note priority="CRITICAL">Core component for multi-tenant auth architecture</note>
                    <note priority="HIGH">Must support both admin and tenant realm operations</note>
                    <note priority="HIGH">Create realm resolution protocol for tenant context</note>
                </migration_notes>
            </file>
            <file path="src/integrations/keycloak/client.py" size="unknown" complexity="MEDIUM">
                <description>Base Keycloak client wrapper</description>
                <migration_notes>
                    <note priority="MEDIUM">May be legacy or synchronous client</note>
                    <note priority="LOW">Evaluate if needed alongside async_client</note>
                </migration_notes>
            </file>
        </file_group>
        
        <!-- Permission Infrastructure -->
        <file_group name="permission_infrastructure" priority="HIGH" dependencies="1">
            <file path="src/features/auth/decorators/permissions.py" size="170_lines" complexity="MEDIUM">
                <description>Permission decorators for endpoint protection</description>
                <migration_notes>
                    <note priority="HIGH">Core component for permission discovery and validation</note>
                    <note priority="MEDIUM">Create protocol for permission validation services</note>
                    <note priority="LOW">Enhance OpenAPI integration</note>
                </migration_notes>
                <current_issues>
                    <issue>Tightly coupled to FastAPI - needs abstraction</issue>
                    <issue>No tenant context support in decorator</issue>
                </current_issues>
            </file>
            <file path="src/features/auth/models/permission_registry.py" size="534_lines" complexity="LOW">
                <description>Static permission definitions for platform and tenant</description>
                <migration_notes>
                    <note priority="HIGH">Foundation for permission system - must be reusable</note>
                    <note priority="MEDIUM">Consider making registry extensible for services</note>
                    <note priority="LOW">Add validation for permission definitions</note>
                </migration_notes>
                <current_issues>
                    <issue>Static registry - no service-specific extensions</issue>
                    <issue>No validation of permission structure</issue>
                </current_issues>
            </file>
        </file_group>
    </files_to_migrate>
    
    <!-- PROTOCOL INTERFACES TO CREATE -->
    <protocol_interfaces>
        <protocol name="KeycloakClientProtocol">
            <description>Core Keycloak operations with realm parameterization</description>
            <methods>
                <method>async def authenticate(username: str, password: str, realm: str) -> TokenResponse</method>
                <method>async def introspect_token(token: str, realm: str) -> IntrospectionResponse</method>
                <method>async def refresh_token(refresh_token: str, realm: str) -> TokenResponse</method>
                <method>async def get_userinfo(token: str, realm: str) -> UserInfo</method>
                <method>async def logout(refresh_token: str, realm: str) -> bool</method>
            </methods>
        </protocol>
        
        <protocol name="RealmProviderProtocol">
            <description>Realm resolution for tenant context</description>
            <methods>
                <method>async def get_admin_realm() -> str</method>
                <method>async def get_tenant_realm(tenant_id: str) -> str</method>
                <method>async def resolve_realm_from_context(context: RequestContext) -> str</method>
            </methods>
        </protocol>
        
        <protocol name="TokenValidatorProtocol">
            <description>Token validation with strategy selection</description>
            <methods>
                <method>async def validate_token(token: str, realm: str, strategy: ValidationStrategy) -> TokenClaims</method>
                <method>async def is_token_revoked(token: str) -> bool</method>
                <method>async def revoke_token(token: str, realm: str) -> bool</method>
            </methods>
        </protocol>
        
        <protocol name="PermissionValidatorProtocol">
            <description>Permission checking with tenant context</description>
            <methods>
                <method>async def check_permission(user_id: str, permission: str, tenant_id: Optional[str] = None) -> bool</method>
                <method>async def check_any_permission(user_id: str, permissions: List[str], tenant_id: Optional[str] = None) -> bool</method>
                <method>async def get_user_permissions(user_id: str, tenant_id: Optional[str] = None) -> List[Permission]</method>
            </methods>
        </protocol>
    </protocol_interfaces>
    
    <!-- NEO-COMMONS STRUCTURE -->
    <neo_commons_structure>
        <package path="neo-commons/src/neo_commons/auth">
            <module name="__init__.py">Exports for auth infrastructure</module>
            <module name="protocols.py">All auth protocol interfaces</module>
            
            <subpackage name="keycloak">
                <module name="__init__.py">Keycloak integration exports</module>
                <module name="async_client.py">Enhanced async client with protocol compliance</module>
                <module name="token_manager.py">Token validation and management</module>
                <module name="realm_manager.py">Multi-tenant realm resolution</module>
                <module name="client.py">Base client wrapper (if needed)</module>
            </subpackage>
            
            <subpackage name="permissions">
                <module name="__init__.py">Permission system exports</module>
                <module name="decorators.py">Permission decorators with protocol support</module>
                <module name="registry.py">Permission registry and validation</module>
                <module name="validator.py">Permission validation implementation</module>
            </subpackage>
            
            <subpackage name="providers">
                <module name="__init__.py">Provider implementations</module>
                <module name="realm_provider.py">Default realm resolution implementation</module>
                <module name="admin_realm_provider.py">Admin-specific realm provider</module>
            </subpackage>
        </package>
    </neo_commons_structure>
    
    <!-- SERVICE WRAPPERS -->
    <service_wrappers>
        <wrapper name="src/integrations/keycloak/__init__.py">
            <description>Wrapper that imports from neo-commons and provides backward compatibility</description>
            <implementation>
                <code>
# Service wrapper for neo-commons auth integration
from neo_commons.auth.keycloak import (
    KeycloakAsyncClient as NeoKeycloakAsyncClient,
    TokenManager as NeoTokenManager,
    RealmManager as NeoRealmManager,
    get_keycloak_client as get_neo_keycloak_client,
    get_token_manager as get_neo_token_manager,
    get_realm_manager as get_neo_realm_manager
)
from neo_commons.auth.providers import AdminRealmProvider

# Admin-specific configuration
realm_provider = AdminRealmProvider()

# Service-specific client with admin defaults
class KeycloakAsyncClient(NeoKeycloakAsyncClient):
    def __init__(self):
        super().__init__(realm_provider=realm_provider)

# Backward compatibility
def get_keycloak_client():
    return KeycloakAsyncClient()
                </code>
            </implementation>
        </wrapper>
        
        <wrapper name="src/features/auth/decorators/__init__.py">
            <description>Wrapper for permission decorators with admin defaults</description>
            <implementation>
                <code>
# Service wrapper for neo-commons permission decorators
from neo_commons.auth.permissions import (
    RequirePermission as NeoRequirePermission,
    require_permission as neo_require_permission,
    PermissionMetadata
)
from src.features.auth.dependencies import get_permission_validator

# Admin-specific permission decorator
class RequirePermission(NeoRequirePermission):
    def __init__(self, *args, **kwargs):
        # Default to platform scope for admin API
        kwargs.setdefault('scope', 'platform')
        super().__init__(*args, **kwargs)

# Backward compatibility
def require_permission(*args, **kwargs):
    kwargs.setdefault('scope', 'platform')
    return neo_require_permission(*args, **kwargs)
                </code>
            </implementation>
        </wrapper>
    </service_wrappers>
    
    <!-- MIGRATION STEPS -->
    <migration_steps>
        <phase number="1" name="Protocol Design" duration="4_hours">
            <step>Create auth protocol interfaces in neo-commons</step>
            <step>Define realm provider protocols for multi-tenancy</step>
            <step>Create token validation and permission protocols</step>
            <step>Document protocol contracts and usage patterns</step>
        </phase>
        
        <phase number="2" name="Keycloak Core Migration" duration="8_hours">
            <step>Extract async_client.py to neo-commons with protocol compliance</step>
            <step>Remove hardcoded realm references and add realm provider injection</step>
            <step>Extract token_manager.py with parameterized cache keys</step>
            <step>Create service wrapper in NeoAdminApi for backward compatibility</step>
            <step>Test existing Keycloak authentication flows</step>
        </phase>
        
        <phase number="3" name="Realm Management Migration" duration="6_hours">
            <step>Extract realm_manager.py to neo-commons</step>
            <step>Implement realm provider for admin and tenant contexts</step>
            <step>Create admin-specific realm provider implementation</step>
            <step>Update service wrapper to use admin realm provider</step>
            <step>Test multi-tenant realm resolution</step>
        </phase>
        
        <phase number="4" name="Permission Infrastructure Migration" duration="6_hours">
            <step>Extract permission decorators to neo-commons</step>
            <step>Extract permission registry with validation</step>
            <step>Create permission validator implementation</step>
            <step>Create service wrapper with admin-specific defaults</step>
            <step>Test permission discovery and validation</step>
        </phase>
        
        <phase number="5" name="Integration Testing" duration="4_hours">
            <step>Test complete auth flow with migrated components</step>
            <step>Validate service wrapper backward compatibility</step>
            <step>Test multi-tenant realm switching scenarios</step>
            <step>Performance test cached token validation</step>
            <step>Integration test with existing permission checks</step>
        </phase>
    </migration_steps>
    
    <!-- CRITICAL ISSUES TO ADDRESS -->
    <critical_issues>
        <issue priority="CRITICAL" category="hardcoded_values">
            <description>Multiple hardcoded realm references in token_manager and async_client</description>
            <impact>Prevents multi-tenant usage and service reusability</impact>
            <solution>Replace with injected realm provider protocol</solution>
            <files_affected>
                <file>src/integrations/keycloak/token_manager.py</file>
                <file>src/integrations/keycloak/async_client.py</file>
            </files_affected>
        </issue>
        
        <issue priority="HIGH" category="service_coupling">
            <description>Direct settings dependencies throughout auth infrastructure</description>
            <impact>Tight coupling prevents reuse in other services</impact>
            <solution>Inject configuration through protocol interfaces</solution>
            <files_affected>
                <file>src/integrations/keycloak/async_client.py</file>
                <file>src/integrations/keycloak/token_manager.py</file>
            </files_affected>
        </issue>
        
        <issue priority="HIGH" category="cache_keys">
            <description>Service-specific cache key patterns in token manager</description>
            <impact>Cache conflicts if multiple services use same Redis</impact>
            <solution>Parameterize cache key prefixes and namespacing</solution>
            <files_affected>
                <file>src/integrations/keycloak/token_manager.py</file>
            </files_affected>
        </issue>
        
        <issue priority="MEDIUM" category="protocol_abstraction">
            <description>No protocol interfaces for auth operations</description>
            <impact>Difficult testing and service substitution</impact>
            <solution>Create comprehensive protocol interfaces</solution>
            <files_affected>
                <file>All auth infrastructure files</file>
            </files_affected>
        </issue>
    </critical_issues>
    
    <!-- VALIDATION CHECKLIST -->
    <validation_checklist>
        <functional_tests>
            <test>Keycloak authentication with admin realm works</test>
            <test>Token validation (local and introspection) functions correctly</test>
            <test>Token refresh and logout operations work</test>
            <test>Permission decorators discover and validate permissions</test>
            <test>Realm resolution works for different tenant contexts</test>
            <test>Cache operations maintain tenant isolation</test>
        </functional_tests>
        
        <integration_tests>
            <test>Existing NeoAdminApi auth flows remain functional</test>
            <test>Permission checking integrates with decorated endpoints</test>
            <test>Multi-tenant realm switching works correctly</test>
            <test>Service wrapper maintains backward compatibility</test>
            <test>Protocol implementations pass interface compliance tests</test>
        </integration_tests>
        
        <performance_tests>
            <test>Token validation performance unchanged (sub-50ms)</test>
            <test>Permission checking performance maintained (sub-10ms)</test>
            <test>Cache hit rates remain high (>90%)</test>
            <test>Realm resolution adds minimal overhead (<5ms)</test>
        </performance_tests>
        
        <security_tests>
            <test>Token validation security preserved</test>
            <test>Cache tenant isolation maintained</test>
            <test>Permission checking accuracy unchanged</test>
            <test>Realm isolation prevents cross-tenant access</test>
        </security_tests>
    </validation_checklist>
    
    <!-- SUCCESS CRITERIA -->
    <success_criteria>
        <criterion>All existing auth flows function without changes</criterion>
        <criterion>Neo-commons auth infrastructure passes protocol compliance tests</criterion>
        <criterion>Service wrappers provide seamless backward compatibility</criterion>
        <criterion>Multi-tenant scenarios work with different realm configurations</criterion>
        <criterion>Performance benchmarks meet or exceed original metrics</criterion>
        <criterion>Code reusability demonstrated through protocol interfaces</criterion>
        <criterion>Zero breaking changes for existing API consumers</criterion>
    </success_criteria>
    
    <!-- ROLLBACK PLAN -->
    <rollback_plan>
        <step>Revert service wrapper imports to original implementations</step>
        <step>Remove neo-commons auth dependencies from requirements</step>
        <step>Restore original file imports in affected modules</step>
        <step>Verify all authentication and permission flows work</step>
        <step>Update any tests that may have been modified</step>
    </rollback_plan>
    
    <!-- POST-MIGRATION TASKS -->
    <post_migration_tasks>
        <task>Update NeoTenantApi to use neo-commons auth infrastructure</task>
        <task>Create documentation for auth protocol interfaces</task>
        <task>Establish testing patterns for auth infrastructure</task>
        <task>Create performance benchmarks for auth operations</task>
        <task>Document multi-tenant realm configuration patterns</task>
    </post_migration_tasks>
    
    <!-- RISK ASSESSMENT -->
    <risks>
        <risk level="HIGH" probability="MEDIUM">
            <description>Token validation changes break existing auth flows</description>
            <mitigation>Comprehensive testing with service wrapper compatibility</mitigation>
            <contingency>Immediate rollback to original implementations</contingency>
        </risk>
        
        <risk level="MEDIUM" probability="LOW">
            <description>Permission system changes affect endpoint security</description>
            <mitigation>Maintain exact permission checking logic during migration</mitigation>
            <contingency>Restore original permission decorators</contingency>
        </risk>
        
        <risk level="MEDIUM" probability="MEDIUM">
            <description>Cache key changes break existing token caching</description>
            <mitigation>Maintain compatible cache key patterns in service wrapper</mitigation>
            <contingency>Clear affected cache entries and restart with original keys</contingency>
        </risk>
        
        <risk level="LOW" probability="HIGH">
            <description>Import dependency issues during development</description>
            <mitigation>Incremental migration with service wrapper testing</mitigation>
            <contingency>Fix imports and dependencies as they arise</contingency>
        </risk>
    </risks>
    
    <!-- TIMELINE -->
    <timeline>
        <milestone name="Protocol Design Complete" date="+4_hours" />
        <milestone name="Keycloak Core Migration Complete" date="+12_hours" />
        <milestone name="Realm Management Migration Complete" date="+18_hours" />
        <milestone name="Permission Infrastructure Migration Complete" date="+24_hours" />
        <milestone name="Integration Testing Complete" date="+28_hours" />
        <milestone name="Phase 4.1 Migration Complete" date="+30_hours" />
    </timeline>
    
    <!-- DEPENDENCIES -->
    <dependencies>
        <dependency type="previous_phase">Phase 2.2 - Schema configuration fixes must be complete</dependency>
        <dependency type="infrastructure">Redis cache must be operational for token caching</dependency>
        <dependency type="external">Keycloak instance must be available for testing</dependency>
        <dependency type="internal">NeoAdminApi auth flows must be functional before migration</dependency>
    </dependencies>
</neo_commons_phase_4_1_migration_plan>