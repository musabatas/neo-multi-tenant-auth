<?xml version="1.0" encoding="UTF-8"?>
<investigation timestamp="2025-08-22 04:15:30" requirement="Database schema analysis for user management in NeoMultiTenant project">
  <codebase_findings>
    <files>
      <file path="neo-commons/src/neo_commons/features/users/entities/user.py" relevance="high">
        <purpose>User domain entity with unified structure for both admin and tenant users</purpose>
        <key_components>User dataclass with complete profile, auth, and metadata fields</key_components>
        <dependencies>core.value_objects, config.constants</dependencies>
      </file>
      <file path="neo-commons/src/neo_commons/features/auth/repositories/user_mapping_repository.py" relevance="high">
        <purpose>Repository for Keycloak-to-Platform user ID mapping (currently in-memory)</purpose>
        <key_components>UserMappingRepository with create/get/update/delete methods</key_components>
        <dependencies>core.value_objects.identifiers</dependencies>
      </file>
      <file path="NeoAdminApi/src/features/auth/services/auth_service.py" relevance="high">
        <purpose>Admin authentication service using neo-commons auth features</purpose>
        <key_components>AuthService with login, logout, refresh token methods</key_components>
        <dependencies>neo-commons auth features, Keycloak integration</dependencies>
      </file>
    </files>
    <patterns>
      <pattern name="Unified User Schema" location="Database migrations and neo-commons">
        <description>Both admin.users and tenant_template.users tables share identical structure for cross-schema compatibility</description>
        <usage>Enables dynamic user management across admin and tenant contexts</usage>
      </pattern>
      <pattern name="Keycloak ID Mapping" location="AuthService and UserMappingRepository">
        <description>Platform uses Keycloak user ID as platform user ID for admin users, with tenant-specific mapping for tenant users</description>
        <usage>Simplifies admin authentication while maintaining tenant isolation</usage>
      </pattern>
      <pattern name="Flexible Role Scoping" location="user_roles and user_permissions tables">
        <description>Unified scoping with scope_type (global, tenant, team) and scope_id for flexible permission assignment</description>
        <usage>Supports platform-wide, tenant-specific, and team-specific role assignments</usage>
      </pattern>
    </patterns>
  </codebase_findings>
  
  <database_findings>
    <schemas>
      <schema name="admin">
        <tables>
          <table name="users" relevance="high">
            <columns>
              <![CDATA[
              Core Identity: id (UUID), email, username, external_user_id, external_auth_provider
              Profile: first_name, last_name, display_name, avatar_url, phone, job_title
              Organizational: departments[], company, manager_id 
              Status: status (active/inactive/pending/suspended/archived)
              Activity: invited_at, activated_at, last_activity_at, last_login_at
              Audit: created_at, updated_at, deleted_at
              ]]>
            </columns>
            <relationships>Self-referencing manager_id, referenced by user_roles, user_permissions, teams</relationships>
            <indexes>email, username, external_user_id, status, manager_id, tags</indexes>
          </table>
          <table name="roles" relevance="high">
            <columns>
              <![CDATA[
              Core: id (SERIAL), code, name, description, display_name
              Classification: role_level (system/platform/tenant/owner/admin/manager/member/viewer/guest)
              Behavior: is_system, is_default, requires_approval, scope_type
              Limits: priority, max_assignees, auto_expire_days
              ]]>
            </columns>
            <relationships>Referenced by role_permissions, user_roles</relationships>
            <indexes>code, role_level, is_system, is_default, scope_type</indexes>
          </table>
          <table name="permissions" relevance="high">
            <columns>
              <![CDATA[
              Core: id (SERIAL), code, description, resource, action
              Scope: scope_level (platform/tenant/team/user)
              Security: is_dangerous, requires_mfa, requires_approval
              Config: permission_config (JSONB)
              ]]>
            </columns>
            <relationships>Referenced by role_permissions, user_permissions</relationships>
            <indexes>code, resource, action, scope_level, is_dangerous</indexes>
          </table>
          <table name="user_roles" relevance="high">
            <columns>
              <![CDATA[
              Core: id (UUID), user_id, role_id
              Scoping: scope_type, scope_id (for flexible assignment context)
              Grant: granted_by, granted_reason, granted_at
              Status: expires_at, is_active
              ]]>
            </columns>
            <relationships>FK to users(id), roles(id), users(granted_by)</relationships>
            <indexes>user_id, role_id, scope_type+scope_id, granted_by, is_active, expires_at</indexes>
          </table>
          <table name="user_permissions" relevance="high">
            <columns>
              <![CDATA[
              Core: id (UUID), user_id, permission_id
              State: is_granted, is_active
              Scoping: scope_type, scope_id
              Grant/Revoke: granted_by, granted_reason, revoked_by, revoked_reason
              Expiry: expires_at
              ]]>
            </columns>
            <relationships>FK to users(id), permissions(id), users(granted_by), users(revoked_by)</relationships>
            <indexes>user_id, permission_id, scope_type+scope_id, is_granted, is_active</indexes>
          </table>
        </tables>
        <procedures>See seed data in 02_roles_and_permissions.sql for default roles and permissions</procedures>
      </schema>
      <schema name="tenant_template">
        <tables>
          <table name="users" relevance="high">
            <columns>Identical structure to admin.users - unified schema design</columns>
            <relationships>Self-referencing manager_id, referenced by tenant user_roles/permissions</relationships>
            <indexes>Same as admin.users with tenant_ prefix</indexes>
          </table>
          <table name="roles" relevance="high">
            <columns>Identical to admin.roles but scoped to tenant level</columns>
            <relationships>Used by tenant role_permissions and user_roles</relationships>
            <indexes>Same as admin.roles with tenant_ prefix</indexes>
          </table>
          <table name="permissions" relevance="high">
            <columns>Identical to admin.permissions but tenant-scoped</columns>
            <relationships>Used by tenant role_permissions and user_permissions</relationships>
            <indexes>Same as admin.permissions with tenant_ prefix</indexes>
          </table>
          <table name="user_roles" relevance="high">
            <columns>Identical structure to admin.user_roles</columns>
            <relationships>FK to tenant_template.users and roles</relationships>
            <indexes>Same pattern as admin user_roles</indexes>
          </table>
          <table name="user_permissions" relevance="high">
            <columns>Identical structure to admin.user_permissions</columns>
            <relationships>FK to tenant_template.users and permissions</relationships>
            <indexes>Same pattern as admin user_permissions</indexes>
          </table>
        </tables>
        <procedures>Default tenant roles and permissions seeded during template creation</procedures>
      </schema>
      <schema name="platform_common">
        <tables>
          <table name="shared_functions" relevance="medium">
            <columns>UUID generation, trigger functions, enum types</columns>
            <relationships>Used by all schemas</relationships>
            <indexes>N/A - contains functions and types</indexes>
          </table>
        </tables>
        <procedures>
          <![CDATA[
          uuid_generate_v7() - Time-ordered UUID generation
          update_updated_at_column() - Trigger function for updated_at timestamps
          Enum types: auth_provider, role_level, user_status, permission_scope, team_types
          ]]>
        </procedures>
      </schema>
    </schemas>
  </database_findings>
  
  <framework_documentation>
    <framework name="neo-commons" version="current">
      <relevant_features>
        - Feature-First architecture with auth, users, permissions modules
        - Protocol-based dependency injection with @runtime_checkable
        - Unified User entity supporting both admin and tenant contexts
        - Keycloak integration with user mapping capabilities
        - Database service with dynamic connection management
      </relevant_features>
      <best_practices>
        - Use unified User entity for both admin and tenant users
        - Implement repositories with protocol interfaces
        - Leverage database service for connection management
        - Use UUIDv7 for time-ordered identifiers
      </best_practices>
      <examples>
        <![CDATA[
        # User creation with unified entity
        user = User(
            id=UserId(generate_uuid_v7()),
            email="admin@example.com",
            external_user_id="keycloak_id",
            schema_name="admin"  # or f"tenant_{tenant_id}"
        )
        
        # Database service usage
        async with db_service.get_connection("admin") as conn:
            result = await conn.fetchrow("SELECT * FROM admin.users WHERE id = $1", user_id)
        ]]>
      </examples>
    </framework>
  </framework_documentation>
  
  <recommendations>
    <recommendation priority="high">
      <description>Implement database-backed UserMappingRepository to replace in-memory storage</description>
      <rationale>Current implementation uses in-memory dictionaries which won't persist across restarts</rationale>
      <implementation_notes>
        - Create admin.user_mappings table for Keycloak-to-platform ID mapping
        - Implement async database operations in UserMappingRepository
        - Add proper indexing on keycloak_user_id and tenant_id combinations
      </implementation_notes>
    </recommendation>
    <recommendation priority="high">
      <description>Create admin user repository using existing neo-commons patterns</description>
      <rationale>No repository exists for admin user CRUD operations, needed for user management</rationale>
      <implementation_notes>
        - Create AdminUserRepository following neo-commons repository patterns
        - Implement protocol interface for dependency injection
        - Use dynamic schema resolution (admin vs tenant_template)
        - Integrate with existing database service
      </implementation_notes>
    </recommendation>
    <recommendation priority="medium">
      <description>Implement permission caching service for sub-millisecond performance</description>
      <rationale>Complex role/permission queries need caching for performance targets</rationale>
      <implementation_notes>
        - Extend existing Redis cache service for permissions
        - Cache user permissions by user_id + scope combination
        - Implement cache invalidation on role/permission changes
        - Use neo-commons cache feature module
      </implementation_notes>
    </recommendation>
    <recommendation priority="medium">
      <description>Add database constraints for Keycloak user mapping integrity</description>
      <rationale>Ensure data integrity between Keycloak and platform user IDs</rationale>
      <implementation_notes>
        - Add unique constraints on external_user_id + external_auth_provider
        - Implement foreign key validation where applicable
        - Add check constraints for required fields based on auth provider
      </implementation_notes>
    </recommendation>
  </recommendations>
  
  <summary>
    <key_findings>
      - Unified user schema design supports both admin and tenant users with identical structure
      - Comprehensive RBAC system with flexible scoping (global, tenant, team)
      - Existing auth service uses Keycloak ID directly as platform ID for admin users
      - Seed data includes 8 platform roles (super_admin to platform_viewer) and 8 tenant roles
      - Default admin user: admin@neomultitenant.com with super_admin role
      - Test users available in seed data for different tenant contexts
    </key_findings>
    <existing_implementations>
      - Complete database schema with admin.users, roles, permissions, user_roles, user_permissions
      - Unified User entity in neo-commons supporting both admin and tenant contexts
      - AuthService for admin authentication with Keycloak integration
      - Database service with dynamic connection management
      - Comprehensive permission system with 50+ platform and tenant permissions
      - Working admin authentication flow using environment-based Keycloak config
    </existing_implementations>
    <gaps>
      - UserMappingRepository uses in-memory storage instead of database persistence
      - No AdminUserRepository for CRUD operations on admin users
      - Permission caching not implemented for performance optimization
      - User management endpoints not exposed in admin API
      - Cross-tenant user access patterns not fully implemented
    </gaps>
    <risks>
      - User mapping data loss on service restart due to in-memory storage
      - Performance issues with complex permission queries without caching
      - Potential security issues with direct Keycloak ID usage for admin users
      - Missing audit trail for user management operations
      - No user synchronization mechanism between Keycloak and database
    </risks>
  </summary>
</investigation>