<?xml version="1.0" encoding="UTF-8"?>
<investigation timestamp="2025-08-24 19:07:45" requirement="Analyze complete tenant-related database structure in NeoMultiTenant project">
  <codebase_findings>
    <files>
      <file path="NeoInfrastructure/migrations/flyway/admin/V1003__admin_organization_tenant.sql" relevance="high">
        <purpose>Core tenant management schema in admin database</purpose>
        <key_components>organizations, regions, database_connections, tenants, tenant_contacts tables</key_components>
        <dependencies>admin schema types, platform_common functions</dependencies>
      </file>
      <file path="NeoInfrastructure/migrations/flyway/regional/shared/V2001__tenant_template_schema.sql" relevance="high">
        <purpose>Complete tenant template schema with RBAC system</purpose>
        <key_components>users, permissions, roles, teams, user_roles, user_permissions, team_members, invitations</key_components>
        <dependencies>platform_common functions and enums</dependencies>
      </file>
      <file path="NeoInfrastructure/migrations/flyway/admin/V1001__admin_schema_types.sql" relevance="high">
        <purpose>Admin-specific enum types for tenant and organization management</purpose>
        <key_components>tenant_status, deployment_type, environment_type, contact_type, connection_type enums</key_components>
        <dependencies>platform_common schema</dependencies>
      </file>
      <file path="NeoInfrastructure/migrations/flyway/platform/V0001__platform_common_schema.sql" relevance="high">
        <purpose>Shared platform functions and types across all databases</purpose>
        <key_components>auth_provider, role_level, user_status, permission_scope enums, uuid_generate_v7 function</key_components>
        <dependencies>pgcrypto extension</dependencies>
      </file>
      <file path="NeoInfrastructure/migrations/seeds/admin/04_organizations_and_tenants.sql" relevance="high">
        <purpose>Comprehensive seed data showing real tenant configuration examples</purpose>
        <key_components>Multiple organizations with diverse tenants, multi-region deployment examples</key_components>
        <dependencies>admin.organizations, admin.tenants, admin.regions tables</dependencies>
      </file>
    </files>
    <patterns>
      <pattern name="schema_per_tenant_strategy" location="tenant_template schema + admin.tenants">
        <description>Schema-based multi-tenancy with tenant_template as blueprint schema that gets copied/cloned for each tenant</description>
        <usage>Each tenant gets a unique schema in shared regional database, isolation through PostgreSQL schema separation</usage>
      </pattern>
      <pattern name="multi_region_tenant_distribution" location="admin.regions, admin.database_connections">
        <description>Intelligent tenant placement across US/EU regions based on data residency requirements</description>
        <usage>GDPR-compliant tenants automatically placed in EU regions, US tenants in US regions</usage>
      </pattern>
      <pattern name="dynamic_connection_management" location="neo-commons database service">
        <description>Database connections loaded from admin.database_connections table with automatic failover</description>
        <usage>Centralized credential management with encryption, health monitoring, and automatic connection discovery</usage>
      </pattern>
      <pattern name="flyway_orchestrated_migrations" location="dynamic_migration_engine.py">
        <description>Coordinated database migrations using Flyway with dependency resolution and batch tracking</description>
        <usage>Platform-common → regional shared → tenant-specific migration order with rollback support</usage>
      </pattern>
      <pattern name="keycloak_realm_per_tenant" location="deployment_api.py keycloak provisioning">
        <description>One Keycloak realm per tenant pattern for enterprise-grade isolation</description>
        <usage>tenant-{slug} realm naming, automatic client credential provisioning stored in admin.tenants</usage>
      </pattern>
      <pattern name="comprehensive_rbac_system" location="tenant_template schema permissions/roles">
        <description>Complete role-based access control with scoped permissions, team hierarchies</description>
        <usage>User → role assignments with team/tenant/global scoping, direct permission grants, inheritance</usage>
      </pattern>
    </patterns>
  </codebase_findings>
  
  <database_findings>
    <schemas>
      <schema name="admin">
        <tables>
          <table name="organizations" relevance="high">
            <columns>id UUID, name VARCHAR(255), slug VARCHAR(100), legal_name, industry, business_type, company_size, primary_contact_id UUID, is_active BOOLEAN, verified_at TIMESTAMPTZ</columns>
            <relationships>primary_contact_id -> admin.users(id)</relationships>
            <indexes>slug, name, active, country, primary_contact</indexes>
          </table>
          <table name="regions" relevance="high">
            <columns>id UUID, code VARCHAR(20), name VARCHAR(100), country_code CHAR(2), continent VARCHAR(20), gdpr_region BOOLEAN, is_active BOOLEAN, accepts_new_tenants BOOLEAN</columns>
            <relationships>Referenced by admin.tenants(region_id) and admin.database_connections(region_id)</relationships>
            <indexes>code, active, accepts_tenants, country, gdpr</indexes>
          </table>
          <table name="database_connections" relevance="high">
            <columns>id UUID, region_id UUID, connection_name VARCHAR(100), connection_type admin.connection_type, host VARCHAR(255), port INTEGER, database_name VARCHAR(63), encrypted_password VARCHAR(256)</columns>
            <relationships>region_id -> admin.regions(id), Referenced by admin.tenants(database_connection_id)</relationships>
            <indexes>region, type, active, healthy</indexes>
          </table>
          <table name="tenants" relevance="high">
            <columns>id UUID, organization_id UUID, slug VARCHAR(63), name VARCHAR(255), schema_name VARCHAR(63), deployment_type admin.deployment_type, region_id UUID, database_connection_id UUID, status admin.tenant_status</columns>
            <relationships>organization_id -> admin.organizations(id), region_id -> admin.regions(id), database_connection_id -> admin.database_connections(id)</relationships>
            <indexes>organization, slug, schema_name, status, region, environment, auth_provider</indexes>
          </table>
          <table name="tenant_contacts" relevance="medium">
            <columns>id UUID, tenant_id UUID, user_id UUID, contact_type admin.contact_type, is_primary BOOLEAN</columns>
            <relationships>tenant_id -> admin.tenants(id), user_id -> admin.users(id)</relationships>
            <indexes>tenant, user, type, primary</indexes>
          </table>
        </tables>
        <procedures>None identified</procedures>
      </schema>
      <schema name="tenant_template">
        <tables>
          <table name="users" relevance="high">
            <columns>id UUID, email VARCHAR(320), external_user_id VARCHAR(255), external_auth_provider platform_common.auth_provider, status platform_common.user_status, default_role_level platform_common.role_level</columns>
            <relationships>manager_id -> tenant_template.users(id)</relationships>
            <indexes>email, username, external_id, status, manager, tags, deleted</indexes>
          </table>
          <table name="permissions" relevance="high">
            <columns>id INTEGER GENERATED IDENTITY, code VARCHAR(100), resource VARCHAR(50), action VARCHAR(50), scope_level platform_common.permission_scope, is_dangerous BOOLEAN</columns>
            <relationships>Used by tenant_template.role_permissions and tenant_template.user_permissions</relationships>
            <indexes>code, resource, action, scope, dangerous</indexes>
          </table>
          <table name="roles" relevance="high">
            <columns>id INTEGER GENERATED IDENTITY, code VARCHAR(100), name VARCHAR(150), role_level platform_common.role_level, is_system BOOLEAN, is_default BOOLEAN</columns>
            <relationships>Used by tenant_template.role_permissions and tenant_template.user_roles</relationships>
            <indexes>code, level, system, default, scope_type</indexes>
          </table>
          <table name="teams" relevance="high">
            <columns>id UUID, name VARCHAR(255), slug VARCHAR(100), parent_team_id UUID, team_type platform_common.team_types, owner_id UUID</columns>
            <relationships>parent_team_id -> tenant_template.teams(id), owner_id -> tenant_template.users(id)</relationships>
            <indexes>slug, parent, owner, type, active</indexes>
          </table>
          <table name="user_roles" relevance="high">
            <columns>id UUID, user_id UUID, role_id INTEGER, scope_type VARCHAR(20), scope_id UUID</columns>
            <relationships>user_id -> tenant_template.users(id), role_id -> tenant_template.roles(id)</relationships>
            <indexes>user, role, scope, granted_by, active, expires</indexes>
          </table>
          <table name="user_permissions" relevance="high">
            <columns>id UUID, user_id UUID, permission_id INTEGER, is_granted BOOLEAN, scope_type VARCHAR(20), scope_id UUID</columns>
            <relationships>user_id -> tenant_template.users(id), permission_id -> tenant_template.permissions(id)</relationships>
            <indexes>user, permission, scope, granted, active</indexes>
          </table>
        </tables>
        <procedures>Default roles and permissions are seeded during migration</procedures>
      </schema>
    </schemas>
  </database_findings>
  
  <framework_documentation>
    <framework name="FastAPI" version="latest">
      <relevant_features>Dependency injection, async support, automatic OpenAPI generation</relevant_features>
      <best_practices>Protocol-based dependency injection, middleware for tenant context</best_practices>
      <examples>NeoAdminApi feature-first architecture with tenant routers</examples>
    </framework>
    <framework name="PostgreSQL" version="17+">
      <relevant_features>Schema-based multitenancy, UUIDv7, asyncpg driver, Flyway migrations</relevant_features>
      <best_practices>Dynamic schema resolution, connection pooling, health monitoring</best_practices>
      <examples>tenant_template schema, admin database with connection registry</examples>
    </framework>
    <framework name="Flyway" version="9+">
      <relevant_features>Version-based migrations, placeholder substitution, dependency resolution</relevant_features>
      <best_practices>V{number}__{description}.sql naming, schema-specific migration paths</best_practices>
      <examples>Platform-common (V0001), admin (V1001+), regional (V2001+), analytics (V3001+)</examples>
    </framework>
    <framework name="Keycloak" version="latest">
      <relevant_features>Multi-realm support, client credentials, OpenID Connect</relevant_features>
      <best_practices>One realm per tenant, automatic provisioning, credential storage</best_practices>
      <examples>tenant-{slug} realm pattern, automatic client secret management</examples>
    </framework>
  </framework_documentation>
  
  <recommendations>
    <recommendation priority="high">
      <description>Implement tenant management API endpoints in NeoAdminApi using existing neo-commons patterns</description>
      <rationale>All infrastructure exists but API endpoints are TODO placeholders. Follow existing organization service patterns</rationale>
      <implementation_notes>Use TenantRepository with DatabaseService, implement CRUD with tenant provisioning via deployment API</implementation_notes>
    </recommendation>
    <recommendation priority="high">
      <description>Create TenantRepository and TenantService in neo-commons following Feature-First architecture</description>
      <rationale>Tenant entity exists but no repository/service implementation. Other features follow this pattern successfully</rationale>
      <implementation_notes>Place in neo-commons/src/neo_commons/features/tenants/repositories/ and services/, use database service protocols</implementation_notes>
    </recommendation>
    <recommendation priority="medium">
      <description>Extend deployment API with tenant lifecycle management endpoints</description>
      <rationale>Current API focuses on migrations, needs tenant creation, schema provisioning, activation workflows</rationale>
      <implementation_notes>Add POST /tenants endpoint that coordinates schema creation, migration, and Keycloak provisioning</implementation_notes>
    </recommendation>
    <recommendation priority="medium">
      <description>Implement tenant configuration management using existing TenantConfigurationService patterns</description>
      <rationale>Comprehensive configuration service exists but needs integration with tenant management workflows</rationale>
      <implementation_notes>Connect TenantConfigurationService to TenantService, provide configuration templates and inheritance</implementation_notes>
    </recommendation>
    <recommendation priority="low">
      <description>Add tenant monitoring and health checks to admin dashboard</description>
      <rationale>Database health monitoring exists, extend to tenant-specific metrics and schema health</rationale>
      <implementation_notes>Extend existing health check patterns to include per-tenant schema validation and activity monitoring</implementation_notes>
    </recommendation>
  </recommendations>
  
  <summary>
    <key_findings>
      • Complete database schema exists: admin.organizations, admin.tenants, admin.regions, admin.database_connections
      • tenant_template schema provides full RBAC: users, roles, permissions, teams, user_roles, user_permissions
      • Multi-region architecture: US East (neofast_shared_us) and EU West (neofast_shared_eu) for GDPR compliance
      • Schema-per-tenant strategy implemented with PostgreSQL schema isolation
      • Dynamic migration engine with Flyway orchestration and dependency resolution
      • neo-commons has Tenant entity and TenantConfigurationService but missing repository/service layer
      • Keycloak integration: one realm per tenant with automatic provisioning (tenant-{slug} pattern)
      • Comprehensive seed data showing real multi-org, multi-tenant examples
      • Database connection management: centralized registry with encryption and health monitoring
    </key_findings>
    <existing_implementations>
      • admin.tenants table with full lifecycle management (pending → provisioning → active → suspended → archived)
      • tenant_template schema with complete RBAC system (6 default roles: owner, admin, manager, member, viewer, guest)
      • Multi-region database connections with automatic failover and health monitoring
      • Dynamic migration engine supporting regional and tenant-specific migrations
      • neo-commons DatabaseService with connection pooling and schema resolution
      • Keycloak provisioner with automatic realm/client creation and credential storage
      • Tenant entity with business logic methods (activate, suspend, feature management)
      • TenantConfigurationService with inheritance, templates, and audit capabilities
      • Migration API with tenant-specific schema provisioning support
    </existing_implementations>
    <gaps>
      • NeoAdminApi tenant endpoints are placeholder TODOs - no actual CRUD implementation
      • No TenantRepository in neo-commons following repository pattern
      • No TenantService orchestrating business logic
      • Limited integration between TenantConfigurationService and tenant lifecycle
      • No tenant monitoring/health dashboard components
      • Tenant search and filtering capabilities not implemented
      • Bulk tenant operations not available
    </gaps>
    <risks>
      • Schema naming conflicts if slug validation is insufficient (mitigated by unique constraints)
      • Regional database failover scenarios not fully tested
      • Tenant deletion workflow needs careful schema cleanup coordination
      • Keycloak realm proliferation could impact performance at scale
      • Database connection pool sizing may need adjustment for high tenant density
      • Migration rollback complexity increases with tenant schema dependencies
    </risks>
  </summary>
</investigation>