"""
FastAPI application factory and configuration.
"""
from contextlib import asynccontextmanager
from typing import Any, Dict
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from scalar_fastapi import get_scalar_api_reference
from loguru import logger
import time

from src.common.config.settings import settings
from src.common.database.connection import init_database, close_database
from src.common.cache.client import init_cache, close_cache
from src.common.exceptions.base import NeoAdminException
from src.common.models.base import (
    APIResponse,
    HealthCheckResponse,
    HealthStatus,
    ServiceHealth
)
from src.common.middleware import setup_middleware


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager."""
    # Startup
    logger.info(f"Starting {settings.app_name} v{settings.app_version}")
    logger.info(f"Environment: {settings.environment}")
    
    try:
        # Initialize database connections
        await init_database()
        
        # Initialize cache
        await init_cache()
        
        # Sync permissions on startup
        from src.features.auth.services.permission_manager import PermissionSyncManager
        logger.info("Syncing permissions from code to database...")
        sync_manager = PermissionSyncManager()
        sync_result = await sync_manager.sync_permissions(
            app=app,
            dry_run=False,  # Actually apply changes
            force_update=False  # Only update if changed
        )
        
        if sync_result['success']:
            logger.info(f"Permission sync completed: {sync_result['stats']}")
        else:
            logger.warning(f"Permission sync had issues: {sync_result.get('error')}")
        
        # Initialize other services as needed
        logger.info("Application startup complete")
        
    except Exception as e:
        logger.error(f"Failed to start application: {e}")
        raise
    
    yield
    
    # Shutdown
    logger.info("Shutting down application...")
    
    try:
        # Close database connections
        await close_database()
        
        # Close cache connections
        await close_cache()
        
        logger.info("Application shutdown complete")
        
    except Exception as e:
        logger.error(f"Error during shutdown: {e}")


def create_app() -> FastAPI:
    """Create and configure FastAPI application."""
    
    # Create FastAPI instance
    app = FastAPI(
        title=settings.app_name,
        version=settings.app_version,
        description="Platform Administration API for NeoMultiTenant",
        docs_url="/swagger" if not settings.is_production else None,  # Swagger at /swagger
        redoc_url="/redoc" if not settings.is_production else None,
        openapi_url="/openapi.json" if not settings.is_production else None,
        lifespan=lifespan
    )
    
    # Configure nested tag groups for better API documentation organization
    if not settings.is_production:
        def custom_openapi():
            if app.openapi_schema:
                return app.openapi_schema
            
            from fastapi.openapi.utils import get_openapi
            openapi_schema = get_openapi(
                title=app.title,
                version=app.version,
                description=app.description,
                routes=app.routes,
            )
            
            # Add x-tagGroups for nested tag organization in Scalar
            openapi_schema["x-tagGroups"] = [
                {
                    "name": "Authentication & Authorization",
                    "tags": ["Authentication", "Permissions", "Roles"]
                },
                {
                    "name": "User Management",
                    "tags": ["Platform Users", "User Profile", "User Settings"]
                },
                {
                    "name": "Organization Management",
                    "tags": ["Organizations", "Organization Settings", "Organization Members"]
                },
                {
                    "name": "Tenant Management",
                    "tags": ["Tenants", "Tenant Settings", "Tenant Users"]
                },
                {
                    "name": "Infrastructure",
                    "tags": ["Regions", "Database Connections", "Health"]
                },
                {
                    "name": "ðŸ’³ Billing & Subscriptions",
                    "tags": ["Billing", "Subscriptions", "Invoices", "Payment Methods"]
                },
                {
                    "name": "ðŸ“Š Analytics & Reports",
                    "tags": ["Analytics", "Reports", "Metrics"]
                },
                {
                    "name": "System",
                    "tags": ["Health", "Configuration", "Migrations", "Monitoring"]
                },
                {
                    "name": "Debug",
                    "tags": ["Debug", "Test", "Root"]
                }
            ]
            
            app.openapi_schema = openapi_schema
            return app.openapi_schema
        
        app.openapi = custom_openapi
    
    # Setup organized middleware stack
    middleware_manager = setup_middleware(app)
    logger.info(f"Configured middleware stack for {settings.environment} environment")
    
    # Log middleware status in development
    if settings.is_development:
        middleware_status = middleware_manager.get_middleware_status()
        logger.info("Active middleware:", **middleware_status)
    
    # Exception handlers
    @app.exception_handler(NeoAdminException)
    async def neo_admin_exception_handler(request: Request, exc: NeoAdminException):
        """Handle application-specific exceptions."""
        return JSONResponse(
            status_code=exc.status_code,
            content=APIResponse.error_response(
                message=exc.message,
                errors=[exc.to_dict()]
            ).model_dump()
        )
    
    @app.exception_handler(ValueError)
    async def value_error_handler(request: Request, exc: ValueError):
        """Handle value errors."""
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content=APIResponse.error_response(
                message=str(exc)
            ).model_dump()
        )
    
    @app.exception_handler(Exception)
    async def general_exception_handler(request: Request, exc: Exception):
        """Handle unexpected exceptions."""
        logger.error(f"Unhandled exception: {exc}", exc_info=True)
        
        if settings.is_production:
            message = "An unexpected error occurred"
        else:
            message = str(exc)
        
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content=APIResponse.error_response(
                message=message
            ).model_dump()
        )
    
    # Register routers
    register_routers(app)
    
    # Add Scalar documentation at /docs
    if not settings.is_production:
        @app.get("/docs", include_in_schema=False)
        async def scalar_docs():
            return get_scalar_api_reference(
                openapi_url=app.openapi_url,
                title=app.title,
                scalar_favicon_url="https://fastapi.tiangolo.com/img/favicon.png"
            )
    
    # Add health check endpoint
    @app.get("/health", response_model=HealthCheckResponse, tags=["Health"])
    async def health_check():
        """Health check endpoint."""
        from src.common.database.connection import get_database
        from src.common.cache.client import get_cache
        from src.common.utils.datetime import utc_now
        
        services = {}
        overall_status = HealthStatus.HEALTHY
        
        # Check database
        try:
            start = time.time()
            db = get_database()
            db_healthy = await db.health_check()
            latency = (time.time() - start) * 1000
            
            services["database"] = ServiceHealth(
                name="PostgreSQL",
                status=HealthStatus.HEALTHY if db_healthy else HealthStatus.UNHEALTHY,
                latency_ms=latency
            )
            
            if not db_healthy:
                overall_status = HealthStatus.UNHEALTHY
                
        except Exception as e:
            services["database"] = ServiceHealth(
                name="PostgreSQL",
                status=HealthStatus.UNHEALTHY,
                error=str(e)
            )
            overall_status = HealthStatus.UNHEALTHY
        
        # Check cache
        try:
            start = time.time()
            cache = get_cache()
            cache_healthy = await cache.health_check()
            latency = (time.time() - start) * 1000
            
            services["cache"] = ServiceHealth(
                name="Redis",
                status=HealthStatus.HEALTHY if cache_healthy else HealthStatus.UNHEALTHY,
                latency_ms=latency
            )
            
            if not cache_healthy:
                if overall_status == HealthStatus.HEALTHY:
                    overall_status = HealthStatus.DEGRADED
                    
        except Exception as e:
            services["cache"] = ServiceHealth(
                name="Redis",
                status=HealthStatus.UNHEALTHY,
                error=str(e)
            )
            if overall_status == HealthStatus.HEALTHY:
                overall_status = HealthStatus.DEGRADED
        
        return HealthCheckResponse(
            status=overall_status,
            version=settings.app_version,
            environment=settings.environment,
            timestamp=utc_now(),
            services=services
        )
    
    # Add middleware status endpoint (development only)
    if not settings.is_production:
        @app.get("/middleware", tags=["Debug"], include_in_schema=False)
        async def middleware_status():
            """Get middleware configuration and status."""
            from src.common.middleware import get_middleware_status
            from src.common.middleware.timing import get_performance_summary
            
            return {
                "middleware_status": get_middleware_status(),
                "performance_summary": get_performance_summary(),
                "environment": settings.environment,
                "note": "This endpoint is only available in non-production environments"
            }
        
        @app.get("/metadata-test", tags=["Debug"], include_in_schema=False)
        async def test_metadata():
            """Test endpoint to verify metadata collection."""
            from src.common.database.connection import get_database
            from src.common.cache.client import get_cache
            from src.common.utils.metadata import MetadataCollector
            
            # Simulate some database operations
            db = get_database()
            await db.fetchval("SELECT 1")
            await db.fetchval("SELECT 2")
            
            # Simulate some cache operations
            cache = get_cache()
            await cache.get("test_key_that_does_not_exist")  # Miss
            await cache.set("test_key", "test_value", ttl=10)  # Set
            await cache.get("test_key")  # Hit
            
            return APIResponse.success_response(
                data={
                    "message": "Metadata test endpoint",
                    "operations_simulated": {
                        "db_queries": 2,
                        "cache_operations": 3
                    }
                },
                message="Test completed successfully"
            )
    
    # Root endpoint
    @app.get("/", tags=["Root"])
    async def root():
        """Root endpoint."""
        return {
            "name": settings.app_name,
            "version": settings.app_version,
            "environment": settings.environment,
            "docs": "/docs" if not settings.is_production else None,
            "swagger": "/swagger" if not settings.is_production else None,
            "redoc": "/redoc" if not settings.is_production else None
        }
    
    return app


def register_routers(app: FastAPI) -> None:
    """Register all application routers.
    
    By default, routers are registered without a prefix (e.g., /databases).
    If ENABLE_PREFIX_ROUTES is true, they are ALSO registered with the API prefix.
    """
    
    # Import routers here to avoid circular imports
    from src.features.regions import database_router, region_router
    from src.features.auth.routers.auth import router as auth_router
    from src.features.auth.routers.permissions import router as permissions_router
    from src.features.tenants.routers.v1 import router as tenants_router
    from src.features.organizations.routers.v1 import router as organizations_router
    from src.features.users.routers.v1 import router as users_router
    from src.features.users.routers.me import router as users_me_router
    from src.features.roles import roles_router
    
    # PRIMARY: Register WITHOUT API prefix (default, shown in docs)
    
    # Authentication & Authorization Group
    app.include_router(
        auth_router,
        prefix="/auth",
        tags=["Authentication"]
    )
    app.include_router(
        permissions_router,
        prefix="/permissions",
        tags=["Permissions"]
    )
    app.include_router(
        roles_router,
        prefix="/roles",
        tags=["Roles"]
    )
    
    # User Management Group
    # IMPORTANT: Register /users/me BEFORE /users to avoid path conflicts
    app.include_router(
        users_me_router,
        prefix="/users/me",
        tags=["User Profile"]
    )
    app.include_router(
        users_router,
        prefix="/users",
        tags=["Platform Users"]
    )
    # Future: User Settings routers
    
    # Organization Management Group
    app.include_router(
        organizations_router,
        prefix="/organizations",
        tags=["Organizations"]
    )
    # Future: Organization Settings and Organization Members routers
    
    # Tenant Management Group
    app.include_router(
        tenants_router,
        prefix="/tenants",
        tags=["Tenants"]
    )
    # Future: Tenant Settings and Tenant Users routers
    
    # Infrastructure Group
    app.include_router(
        region_router,
        prefix="/regions",
        tags=["Regions"]
    )
    app.include_router(
        database_router,
        prefix="/databases",
        tags=["Database Connections"]
    )
    # Future: Health monitoring moved here from System group
    
    # OPTIONAL: Also register WITH API prefix (for backward compatibility)
    # Only if explicitly enabled to avoid duplication in docs
    if settings.enable_prefix_routes and settings.api_prefix:
        # Include with prefix but exclude from OpenAPI schema to avoid duplication
        app.include_router(
            auth_router,
            prefix=f"{settings.api_prefix}/auth",
            tags=["Authentication"],
            include_in_schema=False  # Hide from docs to avoid duplication
        )
        app.include_router(
            permissions_router,
            prefix=f"{settings.api_prefix}/permissions",
            tags=["Permissions"],
            include_in_schema=False  # Hide from docs to avoid duplication
        )
        app.include_router(
            roles_router,
            prefix=f"{settings.api_prefix}/roles",
            tags=["Roles"],
            include_in_schema=False  # Hide from docs to avoid duplication
        )
        app.include_router(
            database_router,
            prefix=f"{settings.api_prefix}/databases",
            tags=["Database Connections"],
            include_in_schema=False  # Hide from docs to avoid duplication
        )
        app.include_router(
            region_router,
            prefix=f"{settings.api_prefix}/regions",
            tags=["Regions"],
            include_in_schema=False  # Hide from docs to avoid duplication
        )
        app.include_router(
            tenants_router,
            prefix=f"{settings.api_prefix}/tenants",
            tags=["Tenants"],
            include_in_schema=False  # Hide from docs to avoid duplication
        )
        app.include_router(
            organizations_router,
            prefix=f"{settings.api_prefix}/organizations",
            tags=["Organizations"],
            include_in_schema=False  # Hide from docs to avoid duplication
        )
        # IMPORTANT: Register /users/me BEFORE /users to avoid path conflicts
        app.include_router(
            users_me_router,
            prefix=f"{settings.api_prefix}/users/me",
            tags=["User Profile"],
            include_in_schema=False  # Hide from docs to avoid duplication
        )
        app.include_router(
            users_router,
            prefix=f"{settings.api_prefix}/users",
            tags=["Platform Users"],
            include_in_schema=False  # Hide from docs to avoid duplication
        )
    
    # Register other routers with same pattern as they are implemented
    # app.include_router(auth_router, prefix="/auth", tags=["Authentication"])
    # if settings.enable_prefix_routes and settings.api_prefix:
    #     app.include_router(auth_router, prefix=f"{settings.api_prefix}/auth", tags=["Authentication"], include_in_schema=False)
    
    logger.info("Registered routers with organized tag groups:")
    logger.info("  Auth & Authorization: /auth, /permissions, /roles")
    logger.info("  User Management: /users")
    logger.info("  Organization Management: /organizations")
    logger.info("  Tenant Management: /tenants")
    logger.info("  Infrastructure: /regions, /databases")
    
    if settings.enable_prefix_routes and settings.api_prefix:
        logger.info(f"  ðŸ“¦ Compatibility routes with {settings.api_prefix} prefix (hidden from docs)")